<!DOCTYPE html>
<style>
  div.tooltip {
    position: absolute;
    text-align: center;
    width: 60px;
    height: 28px;
    padding: 2px;
    font: 12px sans-serif;
    background: lightsteelblue;
    border: 0px;
    border-radius: 8px;
    pointer-events: none;
  }
</style>
<head>
  <meta charset="utf-8" />
  <title>Project</title>
</head>
<body>
  <div style="display: flex; flex-direction: column">
    <div
      style="display: flex; flex-direction: row; margin: 20; padding: 20"
    ></div>
    <div style="display: flex; flex-direction: row">
      <div id="linechart"></div>
      <div id="stackedbarchart"></div>
    </div>
  </div>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script src="https://d3js.org/d3-collection.v1.min.js"></script>
  <script src="https://d3js.org/d3-time.v2.min.js"></script>
  <script src="https://d3js.org/d3-time-format.v3.min.js"></script>
  <script src="https://d3js.org/d3-color.v2.min.js"></script>
  <script src="https://d3js.org/d3-dispatch.v2.min.js"></script>
  <script src="https://d3js.org/d3-ease.v2.min.js"></script>
  <script src="https://d3js.org/d3-interpolate.v2.min.js"></script>
  <script src="https://d3js.org/d3-timer.v2.min.js"></script>
  <script src="https://d3js.org/d3-selection.v2.min.js"></script>
  <script src="https://d3js.org/d3-transition.v2.min.js"></script>
  <script src="https://d3js.org/d3-drag.v2.min.js"></script>
  <script src="https://d3js.org/d3-brush.v2.min.js"></script>
  <script>
    let data;
    let aggregatedData;

    let aggregateTimePerSeconds = 600; // 10분 단위로 모음

    let startTime, endTime;

    let lineChartXDomain;

    const lineChartWidth = 1800;
    const height = 100;
    const margin = 30;

    const brush = d3
      .brushX()
      .extent([
        [0, 0],
        [lineChartWidth, height],
      ])
      .on("end", brushed);

    const lineChart = d3
      .select("#linechart")
      .append("svg")
      .attr("width", lineChartWidth + margin * 2)
      .attr("height", height + margin * 2)
      .append("g")
      .attr("transform", `translate(${margin}, ${margin})`);

    let lineChartTooltip = d3
      .select("body")
      .append("div")
      .attr("class", "tooltip")
      .style("opacity", 0);

    let lineChartX, lineChartY;

    main();

    async function main() {
      data = await d3.csv("data.csv");
      initLineChart();
    }

    function aggregateData() {
      aggregatedData = d3
        .nest()
        .key(
          (d) =>
            parseInt(
              Date.parse(d["대여일시"]) / (aggregateTimePerSeconds * 1000)
            ) *
            (aggregateTimePerSeconds * 1000)
        )
        .sortKeys(d3.ascending)
        .rollup((v) => v.length)
        .entries(data);
    }

    function initLineChartAxes() {
      lineChartXDomain = d3.extent(aggregatedData, (d) => +d.key);

      [startTime, endTime] = lineChartXDomain;

      lineChartX = d3
        .scaleTime()
        .domain(lineChartXDomain)
        .range([0, lineChartWidth]);

      lineChartY = d3
        .scaleLinear()
        .domain(d3.extent(aggregatedData, (d) => +d.value))
        .range([height, 0]);
    }

    function initLineChart() {
      aggregateData();
      initLineChartAxes();

      lineChart
        .append("g")
        .attr("id", "linechart_x")
        .attr("transform", `translate(0, ${height})`)
        .call(d3.axisBottom(lineChartX));

      lineChart
        .append("g")
        .attr("id", "linechart_y")
        .call(d3.axisLeft(lineChartY));

      lineChart
        .append("g")
        .attr("id", "linechart_data")
        .selectAll("path")
        .data([aggregatedData])
        .enter()
        .append("path")
        .attr("fill", "none")
        .attr("stroke", "#808080")
        .attr("d", (data) =>
          d3
            .line()
            .x((d) => lineChartX(+d.key))
            .y((d) => lineChartY(+d.value))(data)
        );
      lineChart
        .on("dblclick", (event) => {
          [startTime, endTime] = lineChartXDomain;
          lineChartX.domain(lineChartXDomain);
          lineChart
            .select("#linechart_x")
            .transition()
            .duration(1000)
            .call(d3.axisBottom(lineChartX));
          lineChart
            .select("#linechart_data")
            .select("path")
            .transition()
            .duration(1000)
            .attr(
              "d",
              d3
                .line()
                .x((d) => lineChartX(+d.key))
                .y((d) => lineChartY(+d.value))(aggregatedData)
            );
        })
        .on("mouseover", function (event, d) {
          let pageX = event.pageX;
          let pageY = event.pageY;
          lineChartTooltip.transition().style("opacity", 0.9);
          lineChartTooltip
            .html(d3.timeFormat("%x %X")(lineChartX.invert(pageX)))
            .style("left", pageX + "px")
            .style("top", pageY - 28 + "px");
        })
        .on("mouseout", (d) => {
          lineChartTooltip.transition().duration(200).style("opacity", 0);
        });

      lineChart.append("g").attr("class", "brush").call(brush);
    }

    function brushed({ selection }) {
      if (!selection) return;
      [startTime, endTime] = selection;

      lineChartX.domain([
        lineChartX.invert(startTime),
        lineChartX.invert(endTime),
      ]);
      lineChart.select(".brush").call(brush.move, null);

      lineChart
        .select("#linechart_x")
        .transition()
        .duration(1000)
        .call(d3.axisBottom(lineChartX));
      lineChart
        .select("#linechart_data")
        .select("path")
        .transition()
        .duration(1000)
        .attr(
          "d",
          d3
            .line()
            .x((d) => lineChartX(+d.key))
            .y((d) => lineChartY(+d.value))(aggregatedData)
        );
    }
  </script>
</body>
